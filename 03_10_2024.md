# Day 3

## Things I learned

1. Web pages and other contents are delievered by __views__. Each view is represented by a function (or method in the case of class-based views). Django will choose a view by examining the requested URL (the part of the URL after the domain name)
2. All POST forms that are targeted at internal URLs should use the `{% csrf_token %}` template tag. Since Django comes with a system for protecting against Cross Site Requests Forgeries, we need not worry about that.
3. Always return an `HttpResponseRedirect` after successfully dealing with POST data. (General good web development practice)

## Bugs

Function at issue

```python
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST["choice"])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(
            request,
            "polls/details.html",
            {
                "question": question,
                "error_message": "You didn't select a choice."
            }
        )
    else:
        selected_choice.votes = F("votes") + 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing with POST data.
        # This prevents data from being posted twice if a user hits the Back button.
        return HttpResponseRedirect(reverse("polls:results", args=(question_id)))
```

Issue Description:
1. TypeError: Value after * must be an iterable, not int

Solution:
modifed 
```python
return HttpResponseRedirect(reverse("polls:results", args=(question_id)))
```

to 

```python
return HttpResponseRedirect(reverse("polls:results", args=(question_id,)))
```

Specifically
Modify `args=(question_id)` to `args=(question_id,)`
Added a comma to make it an iterable
